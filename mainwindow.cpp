#include "mainwindow.h"
#include "ui_mainwindow.h"

// include libs here since the mainwindow.h was generated by mainwindow.ui
#include <iostream>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>
#include <thread>
#include <vector>
#include <thread>

// global variables
HWND gameWindowHandle = nullptr;
DWORD gameProcessID = 0;
HANDLE gameHandle = nullptr;

// last read value as global variable
int readValueInt = 0;
float readValueFloat = 0.0;
double readValueDouble = 0.0;
int readValuePtr = 0; // this will be base 16

// function used to get the output from the commands
// get process workflow:
/*
 * Using win32 api function: CreateProcessW, where its command line can input with powershell and windows can find that app and execute the following commands
 * Using pipe: the pipe will be used for share memory communication
 * this is much more efficient! no screen opens!
 */
std::string exec(const std::wstring& command) { // get the powershell command as input:
    std::string output_string;
    // first we create pipe which can share memory -> used for communication
    HANDLE readPipe = nullptr; // note PHANDLE means HANDLE pointer not pipe's handle
    HANDLE writePipe = nullptr; // do not declare handle here, since I need to use later

    SECURITY_ATTRIBUTES sa; // security attribute struct needed for create pipe function's parameter
    sa.nLength = sizeof(SECURITY_ATTRIBUTES); // doc
    sa.bInheritHandle = TRUE; // we need this to inherit from the pipe otherwise the app will be isolated and communication fails
    sa.lpSecurityDescriptor = nullptr; // default security with access token
    if (CreatePipe(&readPipe, &writePipe, &sa, 0) == 0) {
        throw std::runtime_error("Unable to create a pipe!");
    }

    STARTUPINFOW siw;
    ZeroMemory(&siw, sizeof(STARTUPINFOW));
    siw.cb = sizeof(STARTUPINFOW);
    siw.lpReserved = nullptr;
    siw.dwFlags |= STARTF_USESTDHANDLES; // using or since all others are now 0
    siw.hStdInput = nullptr; // the read is later we can read the result from it
    siw.hStdOutput = writePipe; // the powershell write output to pipe
    siw.hStdError = writePipe; // the powershell also should write error to pipe

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    std::vector command_buffer(command.begin(), command.end()); // copy the command to buffer (the command may be const)
    command_buffer.push_back(L'\0'); // copy did not contain the \0 so add \0 manually
    if (!CreateProcessW(nullptr, command_buffer.data(), nullptr, nullptr, TRUE, CREATE_NO_WINDOW, nullptr, nullptr, &siw, &pi)) {
        CloseHandle(readPipe);
        CloseHandle(writePipe);
        throw std::runtime_error("CreateProcess failed");
    }

    CloseHandle(writePipe); // we have done writing

    // read the output from the pipe
    // note that in windows, readFile can read handle infomation
    std::vector<char> buffer(4096);
    DWORD bytesRead;

    while (ReadFile(readPipe, buffer.data(), buffer.size(), &bytesRead, nullptr) && bytesRead != 0) {
        output_string.append(buffer.data(), bytesRead);
    }

    // clean up: close pipe
    CloseHandle(readPipe);
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return output_string;
}

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    setWindowTitle("Easy Reverse");
}

MainWindow::~MainWindow()
{
    delete ui;
}

void executeCommand(std::string *result, const std::wstring *command) { // NOLINT
    *result = exec(*command); // store the command output to result
}

void MainWindow::on_btnGetHandle_clicked()
{
    // HWND is a handle to a window
    const auto myHandle = reinterpret_cast<HWND>(this->winId()); // HWND for handle
    // we are running in cmd condition, so we call powershell and use command to find the process and return the window name
    // get the name string first
    const std::wstring gameName = ui->txtGameName->text().toStdWString();
    const std::wstring command = L"powershell -noprofile -command \"Get-Process | Where-Object { $_.MainWindowTitle -Like '*" + gameName + L"*' } | Select-Object -ExpandProperty MainWindowTitle\"";
    // create a thread here to avoid lag in app: we need a function:
    // std::string resultTarget = exec(command);
    std::string resultTarget;
    std::thread newThread(executeCommand, &resultTarget, &command);
    newThread.detach();
    // std::cout << "result is:" << resultTarget << "<-" << std::endl;
    // remove all the \n\r\t which might influence the search for window
    size_t endStrings = resultTarget.find_last_not_of(" \n\r\t"); // find_last_not_of has internal loop and find the first one not included in the bracket NOLINT
    if( std::string::npos != endStrings ) {
        resultTarget = resultTarget.substr( 0, endStrings + 1 );
    }

    std::cout << resultTarget << std::endl;


    // casting to LPCSTR according to doc
    const LPCSTR gameProcess = resultTarget.c_str();
    HWND target = FindWindowA(NULL, gameProcess); // NOLINT
    if (target == nullptr) {
        QWidget::setWindowTitle("Easy Reverse : Error"); // NOLINT
        MessageBoxW(myHandle, L"Error! Could not find the process handle!", L"Error", MB_OK | MB_ICONERROR);
        return;
    }

    // when we got the handle, we can open process:
    // note the DWORD is a 32-bit unsigned integer used to store the process ID
    DWORD processID;
    GetWindowThreadProcessId(target, &processID);
    // check valid:
    if (processID == 0) {
        MessageBoxW(myHandle, L"Error! Invalid process ID!", L"Error", MB_OK | MB_ICONERROR);
        return;
    }

    // now we can have handle to kernel objects:
    HANDLE gameKernelProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID); // NOLINT
    // check:
    if (gameKernelProcess == nullptr) {
        MessageBoxW(myHandle, L"Error! Invalid handle to kernel objects!", L"Error", MB_OK | MB_ICONERROR);
        return;
    }
    // if we can reach here, it means we get the correct process, update window for info
    QString updateName = QString::fromStdString(resultTarget);
    QWidget::setWindowTitle("Selected: "+ updateName); // NOLINT
    // store all necessary things in global varibles:
    gameWindowHandle = target;
    gameProcessID = processID;
    gameHandle = gameKernelProcess;
}



void MainWindow::on_btnRead_clicked() // NOLINT
{
    // first check handle state:
    if (gameProcessID == 0) {
        return; // doing nothing since we did not initialize
    }
    // otherwise start reading and write value:
    // first get the address from the box:
    QString readAddressString = ui->txtInputAddress->text(); // NOLINT
    QString showValue;
    bool conversion = false;
    uintptr_t targetAddress = readAddressString.toULongLong(&conversion, 16); // return in unsigned long-long with base 16!
    auto targetReadingAddress = (LPCVOID)targetAddress; // NOLINT
    switch (ui->boxDataType->currentIndex()) {
    case 0: // this is int
        ReadProcessMemory(gameHandle, targetReadingAddress, &readValueInt, sizeof(readValueInt), NULL);
        showValue = QString::number(readValueInt);
        break;
    case 1:
        ReadProcessMemory(gameHandle, targetReadingAddress, &readValueFloat, sizeof(readValueFloat), NULL);
        showValue = QString::number(readValueFloat);
        break;
    case 2:
        ReadProcessMemory(gameHandle, targetReadingAddress, &readValueDouble, sizeof(readValueDouble), NULL);
        showValue = QString::number(readValueDouble);
        break;
    case 3:
        ReadProcessMemory(gameHandle, targetReadingAddress, &readValuePtr, sizeof(readValuePtr), NULL);
        showValue = QString::number(readValuePtr, 16); // with base 16
        break;
    default:
        ReadProcessMemory(gameHandle, targetReadingAddress, &readValueInt, sizeof(readValueInt), NULL);
        showValue = QString::number(readValueInt);
        break;
    }

    ui->txtOutput->setText(showValue);
}


void MainWindow::on_btnWrite_clicked() // NOLINT
{
    if (gameProcessID == 0) {
        return; // doing nothing since we did not initialize
    }
    QString writeAddressString = ui->txtInputAddress->text(); // NOLINT
    bool conversion = false;
    uintptr_t targetAddress = writeAddressString.toULongLong(&conversion, 16); // return in unsigned long-long with base 16!
    auto targetWrittingAddress = reinterpret_cast<LPVOID>(targetAddress); // NOLINT
    int writeValueInt = ui->txtOutput->text().toInt(); // NOLINT
    WriteProcessMemory(gameHandle, targetWrittingAddress, &writeValueInt, sizeof(writeValueInt), NULL);
    QString showValue = QString::number(writeValueInt);
    ui->txtOutput->setText(showValue);
}
